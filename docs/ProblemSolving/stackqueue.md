---
layout: default
title: 스택과 큐
nav_order: 3
parent: ProblemSolving
permalink: docs/problemsolving/stackqueue
---

# 스택과 큐   
{: .no_toc }

{: .no_toc .text-delta }

1. TOC
{:toc}

---

## 스택 (Stack)
**스택(Stack)**은 데이터를 일시적으로 저장하기 위해 사용하는 자료구조입니다. 스택의 데이터 입력과 출력의 순서는 **LIFO(Last In First Out)**, 후입선출입니다. 가장 먼저 들어간 것이 가장 나중에 나오는 형태로, 바구니에 물건을 담을 때를 생각하면 됩니다.

스택의 가장 위 요소는 가장 나중에 들어간 데이터입니다. 주로 **top**이라고 표현하며, 반대로 가장 아래 요소는 가장 먼저 들어간 데이터로 **bottom**이라고 합니다. 스택에 데이터를 입력하는 것을 "**push**한다."고 하며, 데이터를 추출하는 것은 "**pop**한다."라고 합니다. 스택에 들어있는 데이터들을 모두 조회할 순 있지만 **top에 있는 데이터만 접근 가능한**, 제한적인 자료구조입니다. 데이터를 추가할 때도 top위에, 삭제할 때도 top에 있는 것을 삭제합니다. 커다란 바구니에서 위에 있는 것들을 만지지 않고 바구니 가장 아래에 있는 것만 꺼낼 수 없는 것과 같은 이치입니다.

---

## 큐 (Queue)
**큐(Queue)**는 스택과 마찬가지로 데이터를 일시적으로 저장하기 위해 사용하는 자료구조입니다. 큐의 데이터 입력과 출력의 순서는 **FIFO(First in First Out)**, 선입선출입니다. 가장 먼저 들어간 것이 가장 먼저 나오는 형태로, 줄을 서거나 도로 교통을 생각하면 됩니다.

큐의 가장 앞 요소는 가장 먼저 들어간 데이터입니다. 주로 **front**라고 하며, 가장 뒤에 있는 요소는 제일 나중에 들어간 데이터로 **rear**라고 합니다. 큐에 데이터를 입력하는 것을 "**inqueue**한다.", 데이터를 추출하는 것은 "**dequeue**한다."라고 합니다. 큐는 선입선출 구조이기 때문에 배열 등을 이용해 구현할 때 데이터 추출 시 큐 안의 모든 요소를 이동해야합니다. 이 작업은 시간 복잡도가 $O(n)이나 되기 때문에 큐의 크기가 커질 수록 비효율적입니다. 따라서 **Ring Buffer** 자료구조를 이용해 큐를 구현합니다. Ring Buffer는 배열의 앞과 끝이 연결되어있다고 보는 자료구조로 실제 물리적 구조가 원형은 아닙니다.